### Refactoring 요점 정리

    - 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가한다.
    - 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.
    - 아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다.
    - 리팩터링은 프로그램 수정을 작은 단계로 나누어 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
    - 좋은 코드라면 하는 일이 명확히 드러나야 하며, 이때 변수 이름은 커다란 역할을 한다. 그러니 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 말기 바란다.
    - 지역 변수를 제거해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다. 유효범위를 신경 써야 할 대상이 줄어들기 때문이다. 실제로 나는 추출 작업 전에는 거의 항상 지역 변수부터 제거한다.
    - 무엇보다도 반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다. 이처럼 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복(2~3)은 성능에 미치는 영향이 미미할 때가 많다.
    - 간결함이 지혜의 정수일지 몰라도, 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수이다.
    - '항시 코드베이스를 작업하기 전보다 더 건강하게 고친다.'라는 캠핑 규칙의 변경 버전을 적용한다. 완벽하지는 않더라도, 분명 더 나아지게 한다.
    - 좋은 코드를 가늠하는 확실한 방법은 '얼마나 수정하기 쉬운가'다.
    - 리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다.


### Refactoring 원칙

    - 리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다. 개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다. 따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.
    - 리팩터링 과정에서 발견된 버그는 리팩터링 후에도 그대로 남아 있어야 한다.
    - 소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다. 전체 작업 시간이 10분 정도로 짧다 해도, 항상 내가 쓰고 있는 모자(기능추가/리팩터링)가 무엇인지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다.
    - 리팩터링하면 소프트웨어 설계가 좋아지고, 이해하기 쉬워진다. 버그를 쉽게 찾을 수 있고, 프로그래밍 속도를 높일 수 있다.
    - 준비를 위한 리팩터링(Preparatory Refactoring)으로 상황을 개선해 놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다.
    - 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다. 이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를 결코 발견할 수 없다.
    - 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
    - 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다.) 그런 다음 쉽게 수정하자.
    - 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
    - 자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 때문이다. 이때 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는데 있다. 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다. 또한 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다. 자가 테스트 코드 없이 리팩터링할 때는 당연히 이 점을 염려해야 한다. ( 테스트 코드의 중요성. 너무도 당연한 것이다. )




## Refactoring Tip

```ts
function amountFor(aPerformance, play) { // 변수 이름을 명확하게 변경
    // ...
}
```

```ts
// 인라인 처리 전
const play = playFor(perf); // 인라인된 변수는 제거
let thisAmount = amountFor(perf, play); // 인라인 처리 필요

// 인라인 처리 후
let thisAmount = amountFor(perf, playFor(perf));
```

```ts
function statement(invoice, plays) {
    // ...
    function amountFor() {
        // ...
    } // amountFor() 끝
} // statement() 끝
```

```ts
// Javascript의 getter와 setter를 잘 활용하자.
// getter와 setter함수는 별도의 클래스 처리해 보자.
class Performance { // 기본이 되는 class
    constructor(aPerformance, aPlay) {
        this.performance = aPerformance;
        this.play = aPlay;
    }
    get amount() {
        return this.performance;
    }
    get volume() {
        return this.play;
    }
}
class Test1 extends Performance { // extends에서 선언되지 않은 constructor()와 volume()는 Performance class의 constructor()와 volume()를 사용한다.
    get amount() {
        return this.performance * 2;
    }
}
class Test2 extends Performance { // extends에서 선언되지 않은 constructor()와 amount()는 Performance class의 constructor()와 amount()를 사용한다.
    get volume() {
        return this.play / 2;
    }
}
```
